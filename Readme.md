# U.S. Championship V'ball

This is the emulation of V'Ball from Technos Japan ported to MiSTerFPGA by Pierre Cornier (Pierco).

## Technical information

I started with a bootleg version of the board. My idea was to beep the lines with a multimeter to verify the connections between chips. I also had to read the Mame version to understand some tricky parts of it, like how graphic decoding works.

### About the PCB

It has a lot of ROM chips, I counted 17 ROMs plus some small ones for the colors. The original game has less ROMs visible because of a Toshiba package that embeds most of the background graphics.

The board has two CPUs, a 6502 that is used for game logic and a Z80 for sound & music. They communicate by writing/reading to a 8bit register that is visible at $100D for the 6502 and $A000 for the Z80. When the 6502 writes to that register, it generates a NMI so that it triggers a read from the Z80.

The music is generated by a YM2151 that is controlled by the Z80. The line 0 of the address bus is directly connected to the YM. The CPU data bus is also connected to the YM data lines. It seems to be the standard way to connect the YM2151 to a CPU.

Todo, write about OKI...

About the video output, the screen resolution is 240x240 with horizontal orientation. The colors are 12bit and generated by a DAC made of three groups of 4 resistors. According to Mame, the vertical frequency is 58Hz but I need to verify for the bootleg version.

### About the Port

I stored the background tiles in SDRAM because ROMs were too big to be saved in the internal block RAM. The tilemap is organized as four (2x2) screens, bottom left is used to display the title screen but during game only the two lower screens are used. The background decoding is based on two pairs of 4 interlaced bits: 7/5/3/1 & 6/4/2/0. Decoding is done in three steps, first it reads the tile id from video ram, then it reads tile data from SDRAM and finally it reads the corresponding color in palette ROMs.

The sprite RAM can contain up to 64 sprites, each sprite is 4 bytes. The memory layout is Y coordinate, attribute data, the lower part of sprite ID and X coordinate. In my implementation, the core uses two line buffers to render sprites. It alternates between them so the core can render a buffer while it processes the next one. The sprites are decoded in three steps: the sprite attribute is decoded from sprite RAM, then sprite data from sprite ROMs and finally it reads the corresponding color in palette. There are two sprite ROMs, 64k each for a total of 128k. Each pixel is made of 4 bits, two are located in the first ROM and two in the second ROM. The four extracted bits are then combined with the bank and attribute data to build the final palette address.

## Games provided

- U.S. Championship V'ball (US)
- U.S. Championship V'ball (Bootleg of US set)

--

TODO:
- vga output
- horizontal sprite bug when half visible
- flip screen option
- audio
- DIPS in mra file are killing the core!

